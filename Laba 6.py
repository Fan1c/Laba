#Лабораторная работа №6
#Задана рекуррентная функция. Область определения функции – натуральные числа.
#Написать программу сравнительного вычисления данной функции рекурсивно и итерационно (значение, время).
# Определить (смоделировать) границы применимости рекурсивного и итерационного подхода.
# Результаты сравнительного исследования времени вычисления представить в табличной и графической форме в виде отчета по лабораторной работе
#22. F(0) = F(1) = 10, F(n) = (-1)^n*(F(n–2)!–2*F(n-1) /(2n)!), при n > 1

import time
import math
import matplotlib.pyplot as plt #упрощает создание графиков
import pandas as pd #для обработки и анализа данных. интегрируется с библиотекой matplotlib. используем для DataFrame

results=[] #для используется для итерационной функции(возврат к прошлым значениям функции) и для формирования таблицы
# Рекурсивная реализация
def fact(n):
    s=1
    for i in range(2, n+1):
        s=s*i
    return s

def F_rec(n):
    if n == 1 or n==0:  # F(1) = 1
        return 10
    if n > 1:
        return (1 if n % 2 == 0 else -1) * (fact(int(F_rec(n - 2))) - ((2 * F_rec(n - 1)) / (fact(2 * n) if 2*n < 171 else float('inf'))))


# Итерационная
def F_iter(n):
    if n == 0 or n == 1:
        return 10
    #Инициализируем переменные для хранения F(n-2) и F(n-1)
    fn_minus_2 = 10  # F(0)
    fn_minus_1 = 10  # F(1)
    factorial = 2 # (2n)!

    for i in range(2, n + 1):
        factorial *= (2 * i) * (2 * i - 1)  # Вычисление (2i)!
        fact_fn_minus_2 = 1
        for j in range(1, fn_minus_2 + 1):
            fact_fn_minus_2 *= j
        fn = (1 if i % 2 == 0 else -1) * (fact_fn_minus_2 - ((2 * fn_minus_1) / factorial if 2*i < 171 else float('inf')))
        # Обновление значений для следующей итерации
        fn_minus_2, fn_minus_1 = fn_minus_1, fn

    return fn_minus_1


max_n = 3 # Для демонстрации работы рекурсии


for n in range(1, max_n + 1):
    # Итерационный способ
    startI = time.perf_counter()
    f_it = F_iter(n)
    endI = (time.perf_counter() - startI) * 1000

    # Рекурсивный способ
    startR = time.perf_counter()
    f_rec = F_rec(n)
    endR = (time.perf_counter() - startR) * 1000

    results.append({
        'n': n,
        'F_rec': f_rec,
        'F_iter': f_it,
        'Время рекурсии (мс)': endR,
        'Время итерации (мс)': endI
    })

# Создание таблицы и графика
df = pd.DataFrame(results)  # Создает объект DataFrame (нужно для удобства, вывода в ввиде таблицы, и вывода в ввиде графиков)
# (двумерная структура данных, представляющая собой таблицу с метками для строк и столбцов) из списка словарей results
print(df.to_string(float_format="%.6f"))   # Преобразует DataFrame в строку для вывода в консоль,
# Форматирует числа с плавающей точкой, оставляя 6 знаков после запятой,
plt.figure(figsize=(10, 6)) # Создает область для графика 10 на 6 дюймов
plt.plot(df['n'], df['Время рекурсии (мс)'], 'rs-', label='Рекурсия') # 'rs-' красный график, квадр. точки, тип линии - сплошная
plt.plot(df['n'], df['Время итерации (мс)'], 'bs-', label='Итерации')  # 'bs-' синий график, квадр. точки, тип линии - сплошная
plt.xlabel('n') # для подписи оси x
plt.ylabel('Время (мс)') # для подписи оси y
plt.title('Сравнение методов вычисления F(n)') #заголовок
plt.legend()  # Обязательный элемент для графиков с несколькими наборами данных.
# Функция автоматически собирает все метки, указанные в plot(), и отображает их в виде легенды
plt.grid(True) #сетка
plt.show()
